syntax = "proto2";

package trader;

// Security (crypto currency) price (quoted in base currency) at specific time.
message PriceRecord {
  // UNIX timestamp (in seconds).
  optional int32 timestamp_sec = 1;
  // Security (crypto currency) price (quoted in base currency) (e.g. BTC/USD).
  optional float price = 2;
  // Traded security (crypto currency) volume.
  optional float volume = 3;
}

// Open, high, low, and close prices (quoted in base currency) for specific time
// interval. The duration of the time interval is assumed implicitly.
message OhlcTick {
  // UNIX timestamp (in seconds) of the start of the time interval.
  optional int32 timestamp_sec = 1;
  // Opening security (crypto currency) price at the start of the time interval.
  optional float open = 2;
  // Highest security (crypto currency) price during the time interval.
  optional float high = 3;
  // Lowest security (crypto currency) price during the time interval.
  optional float low = 4;
  // Closing security (crypto currency) price at the end of the time interval.
  optional float close = 5;
  // Total traded volume during the time interval.
  optional float volume = 6;
}

// Exchange order.
message Order {
  enum Type {
    MARKET = 0;  // Market order.
    STOP = 1;    // Stop order.
    LIMIT = 2;   // Limit order.
  }
  enum Side {
    BUY = 0;     // Buy order.
    SELL = 1;    // Sell order.
  }
  // Type of the order. Order is invalid if the order type is missing.
  optional Type type = 1;
  // Side of the order. Order is invalid if the order side is missing.
  optional Side side = 2;
  // Target price at which to execute the order. Ignored for market orders.
  // The actual traded price might differ for stop orders.
  optional float price = 3;
  oneof oneof_amount {
    // The amount of security (crypto currency) to by buy / sell.
    float security_amount = 4;
    // The (maximum) amount of cash to be spent on buying (or to be received
    // when selling) the security (crypto currency).
    // The actual traded amount might be smaller due to exchange fees.
    float cash_amount = 5;
  }
}

// Transaction fee configuration.
message FeeConfig {
  // Relative transaction fee.
  optional float relative_fee = 1;
  // Fixed transaction fee in base currency.
  optional float fixed_fee = 2;
  // Minimum transaction fee in base currency.
  optional float minimum_fee = 3;
}

// Trader account configuration.
message TraderAccountConfig {
  // Starting security (crypto currency) balance (e.g. BTC balance).
  optional float start_security_balance = 1;
  // Starting cash balance in base currency (e.g. USD balance).
  optional float start_cash_balance = 2;
  // Smallest indivisible unit for security (crypto currency) balance.
  // Not used if zero.
  optional float security_unit = 3;
  // Smallest indivisible unit for cash balance. Not used if zero.
  optional float cash_unit = 4;
  // Transaction fee configuration for market orders.
  optional FeeConfig market_order_fee_config = 5;
  // Transaction fee configuration for stop orders.
  optional FeeConfig stop_order_fee_config = 6;
  // Transaction fee configuration for limit orders.
  optional FeeConfig limit_order_fee_config = 7;
  // Liquidity for executing market (stop) orders w.r.t. the given OhlcTick
  // from the interval [0; 1].
  // If 1.0 then the market (stop) order will be executed at the opening price
  // (stop order price). This is the best price for the given order.
  // If 0.0 then the buy (sell) order will be executed at the highest (lowest)
  // price of the given OhlcTick. This is the worst price for the given order.
  // Anything in between 0.0 and 1.0 will be linearly interpolated.
  optional float market_liquidity = 8;
  // Fraction of the OhlcTick volume that will be used to fill the limit order.
  // If the actual traded volume * max_volume_ratio is less than the limit
  // order size, then the limit order will be filled only partially.
  // Not used if zero.
  optional float max_volume_ratio = 9;
}

// Result of trader execution over a region of the OHLC history.
message TraderExecutionResult {
  // Security (crypto currency) balance at the beginning of trader execution.
  optional float start_security_balance = 1;
  // Cash balance in base currency at the beginning of trader execution.
  optional float start_cash_balance = 2;
  // Security (crypto currency) balance at the end of trader execution.
  optional float end_security_balance = 3;
  // Cash balance in base currency at the end of trader execution.
  optional float end_cash_balance = 4;
  // Security (crypto currency) price at the beginning of trader execution.
  optional float start_price = 5;
  // Security (crypto currency) price at the end of trader execution.
  optional float end_price = 6;
  // Total value (in base currency) at the beginning of trader execution.
  optional float start_value = 7;
  // Total value (in base currency) at the end of trader execution.
  optional float end_value = 8;
  // Total number of executed exchange orders.
  optional int32 total_executed_orders = 9;
  // Total accumulated transaction fee (in base currency).
  optional float total_fee = 10;
};

// Trader evaluation configuration.
message TraderEvaluationConfig {
  // Starting UNIX timestamp (in seconds).
  optional int32 start_timestamp_sec = 1;
  // Ending UNIX timestamp (in seconds).
  optional int32 end_timestamp_sec = 2;
  // Length of evaluation period (in months).
  optional int32 evaluation_period_months = 3;
}

// Trader evaluation result for a given evaluation configuration.
message TraderEvaluationResult {
  // Trader account configuration.
  optional TraderAccountConfig trader_account_config = 1;
  // Evaluation configuration.
  optional TraderEvaluationConfig trader_eval_config = 2;
  // String representation of the trader (its configuration).
  optional string trader_name = 3;
  // Trader evaluation over a specific period.
  message Period {
    // Starting UNIX timestamp (in seconds) of the evaluation period (included).
    optional int32 start_timestamp_sec = 1;
    // Ending UNIX timestamp (in seconds) of the evaluation period (excluded).
    optional int32 end_timestamp_sec = 2;
    // Result of trader execution over the period.
    optional TraderExecutionResult result = 3;
    // Final percentual gain of the trader (after fees).
    optional float trader_final_gain = 4;
    // Final percentual gain of the baseline (buy and hold) method.
    optional float base_final_gain = 5;
  }
  // Trader evaluation over multiple periods.
  repeated Period period = 4;
  // Trader evaluation score.
  optional float score = 5;
  // Average percentual gain of the trader (after fees).
  optional float avg_trader_gain = 6;
  // Average percentual gain of the baseline method.
  optional float avg_base_gain = 7;
  // Average total number of executed orders.
  optional float avg_total_executed_orders = 8;
  // Average total trader fees in base currency.
  optional float avg_total_fee = 9;
  }

// Stop trader configuration.
message StopTraderConfig {
  // Margin for setting the stop order price w.r.t. the current price.
  optional float stop_order_margin = 1;
  // Margin for moving the stop order price w.r.t. the current price.
  optional float stop_order_move_margin = 2;
  // Maximum relative stop order price increase per day.
  optional float stop_order_increase_per_day = 3;
  // Maximum relative stop order price decrease per day.
  optional float stop_order_decrease_per_day = 4;
}

// Limit trader configuration.
message LimitTraderConfig {
  // Blending factor for the exponential price smoothing.
  optional float alpha_per_hour = 1;
  // Margin for placing the limit order price w.r.t. the smoothed price.
  optional float limit_order_margin = 2;
}

// Limit trader V2 configuration.
message LimitTraderV2Config {
  // Blending factor for the exponential price smoothing.
  optional float alpha_per_hour = 1;
  // Margin for placing the limit buy order price w.r.t. the smoothed price.
  optional float limit_buy_margin = 2;
  // Margin for placing the limit sell order price w.r.t. the smoothed price.
  optional float limit_sell_margin = 3;
}
